import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { Transaction, LanguageType } from '../types';
import { formatRupiah, getMonthYearKey, getMonthName } from './formatters';
import { supabase } from './supabase';

interface ReportData {
  transactions: Transaction[];
  selectedReportKey: string;
  language: LanguageType;
  translations: any;
  accountName: string;
}

export async function generateReportPDF(data: ReportData): Promise<Blob> {
  const { transactions, selectedReportKey, language, translations: t, accountName } = data;

  // Calculate opening balance
  const openingBalance = transactions
    .filter(trans => getMonthYearKey(trans.date) < selectedReportKey)
    .reduce((acc, trans) => acc + (trans.type === 'pemasukan' ? trans.amount : -trans.amount), 0);

  // Filter transactions for the selected month
  const filtered = transactions
    .filter(trans => getMonthYearKey(trans.date) === selectedReportKey)
    .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

  const totalDebit = filtered.filter(t => t.type === 'pemasukan').reduce((acc, curr) => acc + curr.amount, 0);
  const totalCredit = filtered.filter(t => t.type === 'pengeluaran').reduce((acc, curr) => acc + curr.amount, 0);
  const closingBalance = openingBalance + totalDebit - totalCredit;

  // Create PDF
  const doc = new jsPDF('l', 'mm', 'a4'); // Landscape orientation
  const pageWidth = doc.internal.pageSize.getWidth();

  // Header
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.text('FinaryApp', 15, 20);
  
  doc.setFontSize(16);
  doc.text(t.accountingLedger, 15, 30);
  
  doc.setFontSize(11);
  doc.setFont('helvetica', 'normal');
  doc.text(`${t.period}: ${getMonthName(selectedReportKey, language)}`, 15, 37);
  doc.text(`${accountName}`, 15, 43);
  
  // Add generation date
  doc.setFontSize(9);
  doc.setTextColor(100);
  const today = new Date().toLocaleDateString(language === 'id' ? 'id-ID' : 'en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  });
  doc.text(`Generated: ${today}`, pageWidth - 15, 20, { align: 'right' });

  // Prepare table data
  let runningBalance = openingBalance;
  const tableData: any[] = [];

  // Opening balance row
  tableData.push([
    '',
    '',
    t.openingBalance,
    '',
    '',
    '',
    formatRupiah(openingBalance)
  ]);

  // Transaction rows
  filtered.forEach((trans, idx) => {
    const isDebit = trans.type === 'pemasukan';
    runningBalance += isDebit ? trans.amount : -trans.amount;
    
    tableData.push([
      idx + 1,
      new Date(trans.date).getDate(),
      trans.category,
      trans.description || '-',
      isDebit ? formatRupiah(trans.amount) : '',
      !isDebit ? formatRupiah(trans.amount) : '',
      formatRupiah(runningBalance)
    ]);
  });

  // Total row
  tableData.push([
    '',
    '',
    '',
    t.totalFinal,
    formatRupiah(totalDebit),
    formatRupiah(totalCredit),
    formatRupiah(closingBalance)
  ]);

  // Create table
  autoTable(doc, {
    startY: 50,
    head: [[
      'No.',
      t.date,
      t.category,
      t.note,
      t.in,
      t.out,
      t.balance
    ]],
    body: tableData,
    theme: 'striped',
    headStyles: {
      fillColor: [59, 130, 246], // Blue
      textColor: 255,
      fontStyle: 'bold',
      fontSize: 10
    },
    styles: {
      fontSize: 9,
      cellPadding: 3,
    },
    columnStyles: {
      0: { halign: 'center', cellWidth: 15 },
      1: { halign: 'center', cellWidth: 20 },
      2: { halign: 'left', cellWidth: 50 },
      3: { halign: 'left', cellWidth: 60 },
      4: { halign: 'right', cellWidth: 35, textColor: [16, 185, 129] }, // Green for income
      5: { halign: 'right', cellWidth: 35, textColor: [239, 68, 68] }, // Red for expense
      6: { halign: 'right', cellWidth: 35, fontStyle: 'bold' }
    },
    didParseCell: function(data) {
      // Style opening balance row
      if (data.row.index === 0) {
        data.cell.styles.fontStyle = 'italic';
        data.cell.styles.fillColor = [243, 244, 246];
      }
      // Style total row
      if (data.row.index === tableData.length - 1) {
        data.cell.styles.fontStyle = 'bold';
        data.cell.styles.fillColor = [243, 244, 246];
      }
    }
  });

  // Footer
  const finalY = (doc as any).lastAutoTable.finalY || 50;
  doc.setFontSize(8);
  doc.setTextColor(150);
  doc.text('Generated by FinaryApp - Your Personal Finance Tracker', pageWidth / 2, finalY + 15, { align: 'center' });

  return doc.output('blob');
}

export async function downloadPDF(data: ReportData): Promise<void> {
  const blob = await generateReportPDF(data);
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `FinaryApp-Report-${getMonthName(data.selectedReportKey, data.language)}.pdf`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

export async function uploadToGoogleDrive(data: ReportData): Promise<void> {
  try {
    // Get the current session to retrieve Google access token
    const { data: sessionData, error: sessionError } = await supabase.auth.getSession();
    
    console.log('Session check:', { 
      hasSession: !!sessionData?.session, 
      error: sessionError,
      provider: sessionData?.session?.user?.app_metadata?.provider 
    });
    
    if (sessionError) {
      console.error('Session error:', sessionError);
      throw new Error('No active session');
    }
    
    if (!sessionData?.session) {
      console.error('No session found');
      throw new Error('No active session');
    }

    // Check if user logged in with Google OAuth
    const provider = sessionData.session.user.app_metadata?.provider;
    console.log('Auth provider:', provider);
    
    if (provider !== 'google') {
      throw new Error('Not logged in with Google');
    }

    // Get the Google access token
    const accessToken = sessionData.session.provider_token;
    console.log('Has access token:', !!accessToken);
    
    if (!accessToken) {
      throw new Error('No Google access token available');
    }

    // Generate PDF blob
    const pdfBlob = await generateReportPDF(data);
    
    // Prepare file metadata
    const fileName = `FinaryApp-Report-${getMonthName(data.selectedReportKey, data.language)}.pdf`;
    const metadata = {
      name: fileName,
      mimeType: 'application/pdf'
    };

    // Create form data for multipart upload
    const formData = new FormData();
    formData.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
    formData.append('file', pdfBlob);

    // Upload to Google Drive
    const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`
      },
      body: formData
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Google Drive upload error:', errorText);
      throw new Error(`Failed to upload to Google Drive: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('File uploaded to Google Drive:', result);
  } catch (error) {
    console.error('Upload to Google Drive failed:', error);
    throw error;
  }
}